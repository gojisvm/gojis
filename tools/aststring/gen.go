package main

import (
	"go/ast"
	"io/ioutil"
	"log"
	"path"
	"strings"

	j "github.com/dave/jennifer/jen"
)

const (
	headerComment = "Code generated by \"aststring\"; DO NOT EDIT."
	indentPrefix  = "  "
	parOpen       = "("
	parClose      = ")"
)

func generate(fpath string, structs []*structDecl) {
	if len(structs) == 0 {
		// no-op if no structs in file
		return
	}

	filename := fpath + "/ast"
	f := j.NewFilePath(filename)
	f.PackageComment(headerComment)

	for _, structDecl := range structs {
		var calls []j.Code

		calls = append(calls, j.Var().Id("buf").Qual("bytes", "Buffer"))
		calls = append(calls, j.List(j.Id("_"), j.Id("_")).Op("=").Id("buf").Dot("WriteString").Call(j.Lit(structDecl.name+" "+parOpen)))
		calls = append(calls, j.List(j.Id("_"), j.Id("_")).Op("=").Id("buf").Dot("WriteString").Call(j.Lit("\n")))

		for _, field := range structDecl.structType.Fields.List {
			switch field.Type.(type) {
			case *ast.StarExpr:
				for _, fieldName := range field.Names {
					calls = append(
						calls,
						j.If(
							j.Id("node").
								Dot(fieldName.Name).
								Op("!=").
								Nil(),
						).Block(
							j.List(j.Id("_"), j.Id("_")).Op("=").Id("buf").
								Dot("WriteString").
								Call(
									j.Qual(filename, "PrefixToString").
										Call(
											j.Id("node").
												Dot(fieldName.Name).
												Dot("String").
												Call(),
											j.Lit(indentPrefix),
										),
								),
						),
					)
				}
			case *ast.Ident:
				for _, fieldName := range field.Names {
					calls = append(
						calls,
						j.List(j.Id("_"), j.Id("_")).Op("=").Id("buf").
							Dot("WriteString").
							Call(
								j.Qual(filename, "PrefixToString").
									Call(
										j.Qual("fmt", "Sprintf").
											Call(
												j.Lit("%v: %v"),
												j.Lit(fieldName.Name),
												j.Id("node").
													Dot(fieldName.Name),
											),
										j.Lit(indentPrefix),
									),
							),
					)
					calls = append(calls, j.List(j.Id("_"), j.Id("_")).Op("=").Id("buf").Dot("WriteString").Call(j.Lit("\n")))
				}
			case *ast.ArrayType:
				for _, fieldName := range field.Names {
					calls = append(
						calls,
						j.For(j.List(j.Id("_"), j.Id("elem")).Op(":=").Range().Id("node").Dot(fieldName.Name)).
							Block(
								j.List(j.Id("_"), j.Id("_")).Op("=").Id("buf").
									Dot("WriteString").
									Call(
										j.Qual(filename, "PrefixToString").
											Call(
												j.Id("elem").
													Dot("String").
													Call(),
												j.Lit(indentPrefix),
											),
									),
							),
					)
				}
			}
		}

		calls = append(calls, j.List(j.Id("_"), j.Id("_")).Op("=").Id("buf").Dot("WriteString").Call(j.Lit(parClose)))
		calls = append(calls, j.List(j.Id("_"), j.Id("_")).Op("=").Id("buf").Dot("WriteString").Call(j.Lit("\n")))
		calls = append(calls, j.Return(j.Id("buf").Dot("String").Call()))

		f.Func().
			Params(
				j.Id("node").Id("*" + structDecl.name),
			).
			Id("String").
			Params().
			String().
			Block(calls...)

		f.Line()
	}

	outputFile := strings.TrimSuffix(fpath, path.Ext(fpath)) + "_string.go"
	err := ioutil.WriteFile(outputFile, []byte(f.GoString()), 0600)
	if err != nil {
		log.Fatalf("write file: %v", err)
	}
}
